
# [ã€LeetCode ç›´é€šè½¦ã€‘ï¼š234 å›æ–‡é“¾è¡¨ï¼ˆç®€å•ï¼‰](https://leetcode.com/problems/palindrome-linked-list/)

1. æˆ‘ä»¬éå†å‡ºæ•°ç»„åå°†å…¶åè½¬å¯¹æ¯”å³å¯


```javascript

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    const arr = [];
    let cur = head;
    while(cur) {
        arr.push(cur.val);
        cur = cur.next;
    }
    let arr1 = arr.slice().reverse();
    return arr.join('') === arr1.join('')    
};
```

2. è·å–åä½¿ç”¨åŒæŒ‡é’ˆ

```javascript
var isPalindrome = function (head) {
    const arr = [];
    let cur = head;
    while (cur) {
        arr.push(cur.val);
        cur = cur.next;
    }
    let left = 0, right = arr.length -1;

    while(left < right) {
        if(arr[left] !== arr[right]) return false;
        left++;
        right--;
    }

    return true
};
```

4. ç›´æ¥åè½¬é“¾è¡¨åè¿›è¡Œæ¯”è¾ƒ

```javascript

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    const copyList = (list) => {
        let cur = list
        let dummy = new ListNode();
        let curnode = dummy;
        while(cur) {
            curnode.next = new ListNode(cur.val, cur.next);
            cur = cur.next;
            curnode = curnode.next;
        }

        return dummy.next;
    }
    const reverseList = (list) => {
        let dummy = list;
        let pre = null;
        let cur = dummy;
        
        while(cur) {
            const next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next
        }
        return pre;
    }
    const copylist = copyList(head);
    const reverselist = reverseList(head);

    let l1 = copylist, l2 = reverselist;
    while(l1 && l2) {
        if(l1.val !== l2.val) return false;
        l1 = l1.next;
        l2 = l2.next;
    }
    return true
};
```

4. å¿«æ…¢æŒ‡é’ˆ åè½¬ slow åé¢çš„ é“¾è¡¨ä¸ä¹‹å‰çš„å¯¹æ¯”å³å¯ è¾¹ç•Œå¤„ç† å¥‡å¶é—®é¢˜

```javascript

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
    let slow = head, fast= head, l1 = head;

    while(fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    };

    let l2 = reverseList(slow.next);
    while(l2) {
        if(l1.val !== l2.val) return false;
        l1 = l1.next;
        l2 = l2.next;
    }
    return true

};

const reverseList = (list) => {
    let pre = null, cur = list;
    while(cur) {
        const next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre
}
```

# ğŸ‘‰Â [ã€LeetCode ç›´é€šè½¦ã€‘ï¼š206 åè½¬é“¾è¡¨ï¼ˆç®€å•ï¼‰](https://leetcode.com/problems/reverse-linked-list/)

è¿™ä¸ªåœ¨ä¸Šé¢å·²ç»ç”¨åˆ°äº†ï¼Œ å°±æ˜¯å€ŸåŠ©ä¸­é—´å˜é‡ pre ä»¥åŠ cur æ¥è¿›è¡Œå®ç°

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let cur = head;
    let pre = null;
    while(cur) {
        const next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next
    }
    return pre;
};
```

# ğŸ‘‰Â [ã€LeetCode ç›´é€šè½¦ã€‘ï¼š141 ç¯å½¢é“¾è¡¨ï¼ˆç®€å•ï¼‰](https://leetcode.com/problems/linked-list-cycle/)

ç¯å½¢åˆ—è¡¨ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œ å¦‚æœæ˜¯ç¯å½¢é‚£ä¹ˆä»–ä»¬ä¸€å®šä¼šç›¸é‡

```javascript

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let slow = head, fast = head;
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast) return true;
    }
    return false
};
```

æŠŠæˆ‘ç¬‘æ­»çš„è§£æ³•

JSON.stringify(head) ç§’æ€æ³•ğŸ˜ƒ
é™¤éä¸æŠ¥é”™ï¼ŒæŠ¥é”™å°±æ˜¯æœ‰ç¯ï¼ï¼

```javascript
var hasCycle = function (head) {
    try {
        JSON.stringify(head)
    } catch{
        return true
    }
    return false
};
```

# ğŸ‘‰Â [ã€LeetCode ç›´é€šè½¦ã€‘ï¼š160 ç›¸äº¤é“¾è¡¨ï¼ˆç®€å•ï¼‰](https://leetcode.com/problems/intersection-of-two-linked-lists/)

é“¾è¡¨ğŸŒçš„é€»è¾‘å°±æ˜¯ p1 +p2 = p2 + p1 æ‰€ä»¥æ‰€ä»¥è®© p1 èµ°å®Œèµ°p2çš„è·¯å³å¯ ç›¸ç­‰ğŸ”ğŸŒ

```javascript

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    let l1 = headA, l2 = headB;
    while(l1 !== l2) {
        l1 = l1 ? l1.next : headB;
        l2 = l2 ? l2.next : headA;
    }
    return l1
};
```

# [åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.com/problems/merge-two-sorted-lists/)

```javascript
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(list1, list2) {
    let list = new ListNode();
    let dummy = list;
    let l1 = list1, l2 = list2;

    while(l1&&l2) {
        if(l1.val < l2.val) {
            dummy.next = l1;
            l1 = l1.next
        } else {
            dummy.next = l2;
            l2 = l2.next
        }
        dummy = dummy.next;
    }
    dummy.next = l1 ?? l2;
    return list.next;
};
```


# ğŸ‘‰Â [ã€LeetCode ç›´é€šè½¦ã€‘ï¼š148 æ’åºé“¾è¡¨ï¼ˆä¸­ç­‰ï¼‰](https://leetcode.com/problems/sort-list/)

åˆå¹¶æœ‰åºæœ€ç»ˆå¯æ’åº æ‰€ä»¥å°†é“¾è¡¨æ‹†åˆ†æˆæœ€å°å•ä½ 1 ç„¶åè¿›è¡Œåˆå¹¶å³å¯

```javascript
var mergeTwoLists = function(list1, list2) {
    let dummyHead = new ListNode();
    let l1 = list1, l2 =list2, dummy = dummyHead;
    while(l1 && l2) {
        if(l1.val < l2.val) {
            dummy.next = l1;
            l1 = l1.next
        } else {
            dummy.next = l2;
            l2 = l2.next;
        }
        dummy = dummy.next;
    }
    dummy.next = l1 ?? l2;
    return dummyHead.next
};

const getHead = (subLength, curr) => {
    let head = curr;
    for (let i = 1; i < subLength && curr && curr.next; i++) {
        curr = curr.next;
    }
    let nextHead = null;
    if (curr !== null) {
        nextHead = curr.next;
        curr.next = null;
    }
    return [head, nextHead]
}

var sortList = function (head) {
    if (!head) return head;
    let length = 0;
    let node = head;
    while (node) {
        length++;
        node = node.next;
    }
    const dummyHead = new ListNode(0, head);
    for (let subLength = 1; subLength < length; subLength <<= 1) {
        let prev = dummyHead, curr = dummyHead.next;
        while (curr !== null) {
            let head1, head2, nextHead;
            [head1, nextHead] = getHead(subLength, curr)
            curr = nextHead;
            [head2, nextHead] = getHead(subLength, curr);
            curr = nextHead;
            const merged = mergeTwoLists(head1, head2);
            prev.next = merged;
            while (prev.next !== null) {
                prev = prev.next;
            }
        }
    }
    return dummyHead.next;
};


```

# ğŸ‘‰ [ã€LeetCode ç›´é€šè½¦ã€‘ï¼š23 åˆå¹¶Kä¸ªå‡åºé“¾è¡¨ï¼ˆå›°éš¾ï¼‰](https://leetcode.com/problems/merge-k-sorted-lists/)

åˆ†æ²»  æˆ–è€…ä¸¤è¾†åˆå¹¶å³å¯

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if(!lists.length) return null
    while(lists.length>1) {
        lists[0] = merge(lists[0], lists[1]);
        lists.splice(1,1,)
    }
    return lists[0]
};


const merge = (list1, list2) => {
    const dummyHead = new ListNode();
    let dummy = dummyHead, l1 = list1, l2 = list2;
    while(l1 && l2) {
        if(l1.val < l2.val) {
            dummy.next = l1;
            l1 = l1.next
        } else {
            dummy.next = l2;
            l2 = l2.next;
        }
        dummy = dummy.next
    }
    dummy.next = l1 ?? l2;
    return dummyHead.next;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
// åˆå¹¶ä» lists[i] åˆ° lists[j-1] çš„é“¾è¡¨
    function dfs(i, j) {
        const m = j - i;
        if (m === 0) return null; // æ³¨æ„è¾“å…¥çš„ lists å¯èƒ½æ˜¯ç©ºçš„
        if (m === 1) return lists[i]; // æ— éœ€åˆå¹¶ï¼Œç›´æ¥è¿”å›
        const left = dfs(i, i + (m >> 1)); // åˆå¹¶å·¦åŠéƒ¨åˆ†
        const right = dfs(i + (m >> 1), j); // åˆå¹¶å³åŠéƒ¨åˆ†
        return merge(left, right); // æœ€åæŠŠå·¦åŠå’Œå³åŠåˆå¹¶
    }
    return dfs(0, lists.length);
};

```


# ğŸ‘‰ [ã€LeetCode ç›´é€šè½¦ã€‘ï¼š25 K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ï¼ˆå›°éš¾ï¼‰](https://leetcode.com/problems/reverse-nodes-in-k-group/)

```javascript
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    const dummyHead = new ListNode(0, head);
    let pre = dummyHead;
    while(head) {
        let tail = pre;
        for(let i = 0; i < k; i++) {
            tail = tail.next;
            if(!tail) {
                return dummyHead.next;
            }
        }
        const next = tail.next;
        [head, tail] = reverseList(head, tail);
        pre.next = head;
        tail.next = next;
        pre = tail;
        head = tail.next;
    }
    return dummyHead.next;
};

const reverseList = (head, tail) => {
  let pre = tail.next;
  let cur = head;
  while(pre !== tail) {
    const next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return [tail, head]
}
```
  
